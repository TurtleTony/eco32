These are the proposed changes of the ECO32 ISA, triggered by lack
of available opcodes while implementing floating-point arithmetic.

1) Conditional branching instructions:
The following propositions hold, for signed and for unsigned comparisons:
   a >= b    <==>    b <= a
   a > b     <==>    b < a
This enables us to substitute four of the conditional branches:
   bge  r1,r2,lbl   -->   ble  r2,r1,lbl
   bgeu r1,r2,lbl   -->   bleu r2,r1,lbl
   bgt  r1,r2,lbl   -->   blt  r2,r1,lbl
   bgtu r1,r2,lbl   -->   bltu r2,r1,lbl
The substituted branch instructions need not be present as machine
instructions, so their opcodes are free now. Two remarks:
a) It would be nice to be able to use the eliminated instructions in
assembler programs (although in machine code they would disappear).
This is easy to achieve: perform the substitution in the assembler.
Note that the compiler may then issue these instructions unmodified.
b) As a consequence, the disassembler is no longer able to decide
which source form it should output and will choose the one which is
really present in the hardware. I think this is tolerable.
Compiler  : !! FIXME !!
Assembler : !! FIXME !!
Linker    : !! FIXME !!
Monitor   : !! FIXME !!
Simulator : done
Hardware  : !! FIXME !!

2) TLB instructions:
The four TLB instructions all have their applications within OS
kernels, so that we cannot drop any of them. But none of them has
any argument within the instruction itself; all arguments are
supplied via special registers. So only the opcode matters, which
is a big waste of opcodes. The solution is easy and follows the
pattern of the cctl instruction: reserve a single opcode for
"translation control" (named tctl, say) and specify the actual
TLB operation in the remaining bits. The assembler should allow
the original mnemonics to be used as aliases for "tctl <n>":
  tctl 2    tbs     (translation buffer search)
  tctl 3    tbwr    (translation buffer write random)
  tctl 4    tbri    (translation buffer read indexed)
  tctl 5    tbwi    (translation buffer write indexed)
But wait: It is even better to drop "tctl <n>" altogether, in the
assembler as well as the disassembler, and to request using the
"aliases" (which then are no longer aliases, but acquire the status
of first-class instructions, albeit with a different encoding).
Compiler  : !! FIXME !!
Assembler : !! FIXME !!
Linker    : !! FIXME !!
Monitor   : !! FIXME !!
Simulator : done
Hardware  : !! FIXME !!

3) Cache control instructions:
Here we cannot save any opcode, as there is already only a single
one used. But in the interest of being consistent, we should supply
assembler mnemonics for the various cache control operations:
  cctl 2    dci     (data cache invalidate)
  cctl 3    dcf     (data cache flush)
  cctl 4    ici     (instruction cache invalidate)
  cctl 6    cci     (combined caches invalidate)
  cctl 7    ccs     (combined caches synchronize)
As with the TLB instructions, it is better to drop "cctl <n>" and
use the "alias" instructions dci..ccs exclusively.
Compiler  : !! FIXME !!
Assembler : !! FIXME !!
Linker    : !! FIXME !!
Monitor   : !! FIXME !!
Simulator : done
Hardware  : !! FIXME !!

4) Integer remainder instructions:
The four remainder instructions are used to compute the remainder
of an integer division operation. The hardware unavoidably produces
these remainders together with the quotient when executing a division
instruction. So the remainder instructions internally use a division,
but then transfer the remainder (instead of the quotient) to the
destination register. If we are willing to spend a mvfs instruction
for getting at the remainder, every division can always automatically
write the remainder to an additional special register "rem", from
where the software can read it, and thus the four remainder instructions
are no longer needed. Of course they should be available as synthesized
instructions in the assembler (and the compiler can output them without
any changes).
Compiler  : !! FIXME !!
Assembler : !! FIXME !!
Linker    : !! FIXME !!
Monitor   : !! FIXME !!
Simulator : !! FIXME !!
Hardware  : !! FIXME !!

5) Integer multiply instructions:
Each of the four multiply instructions produces the upper 32 bits
of its respective 64-bit result, but these currently cannot be
accessed from software. An additional special register "hi" could
store the bits, which can then be transferred to a general purpose
register with a standard mvfs instruction. Note that multi-precision
integer packages could benefit from this change as well, as they
routinely want to compute the product of two operands of the largest
available integer type, yielding a result with twice as many bits.
Compiler  : !! FIXME !!
Assembler : !! FIXME !!
Linker    : !! FIXME !!
Monitor   : !! FIXME !!
Simulator : !! FIXME !!
Hardware  : !! FIXME !!

6) Integer division/remainder instructions:
Multi-precision integer packages typically rely on an operation which
divides a dividend of 2n bits by a divisor of n bits (and is thus the
inverse of the multiply instruction discussed above). The division
instructions already implemented in ECO32 in fact work like this, but
implicitly set the topmost 32 bits of the 64-bit dividend to zero. If
we are willing to spend a "mvts" instruction to an additional special
register, we could implement the 64-bit-divided-by-32-bit instructions
easily. NOTE: In order not to break any existing (assembler) programs,
we must use the mnemonics div, divi, divu, divui only for synthesized
division instructions (with a prepended mfts $0,<hi> instruction) and
invent four new mnemonics for the bare machine instructions.
Compiler  : !! FIXME !!
Assembler : !! FIXME !!
Linker    : !! FIXME !!
Monitor   : !! FIXME !!
Simulator : !! FIXME !!
Hardware  : !! FIXME !!
